---
title: "Road Network"
author: "Juan Fonseca"
format: html
---
```{r libraries}
library(tidyverse)
library(dodgr)
library(osmextract)
library(sf)
library(tmap)
library(stplanr)
```

The following code uses some functions compiled in the `MinorRoadTraffic` repository prepared by Malcolm Morgan and follows the process described in [this vignette](https://github.com/ITSLeeds/MinorRoadTraffic/blob/main/vignettes/IOW.Rmd) of the same package.

```{r minor_library}
# remotes::install_github("ITSLeeds/MinorRoadTraffic") # if not installed
library(MinorRoadTraffic)
```

## Downloading data

For this analysis, OpenStreetMap will be used for the road network.

```{r osm_get}
osm_raw <- oe_get("East Yorkshire with Hull",
                 extra_tags = c("ref", "highway", "junction", "maxspeed","oneway"))
```

An alternative source can be the [OS Open Roads](https://osdatahub.os.uk/downloads/open/OpenRoads).

## Clipping road network

The count data will be used to clip the road network.
```{r sf_counts}
sf_counts <- st_read("03_preprocessing_files/grouped_counts.geojson")
```


```{r clipping}
buffer_distance = max(st_distance(sf_counts,sf_counts))*0.15

bounds <- sf_counts |>
  make_convex_hull(dist = buffer_distance)

osm_clean = extract_from_osm(osm_raw,
                             bounds,
                             col_names = c("osm_id","name","ref","highway",
                                           "junction","maxspeed","geometry","oneway"))

network = osm_clean$network
rm(osm_clean, osm_raw)
```

```{r saving_bounds,include=FALSE}
try(file.remove("03_preprocessing_files/bounds.geoJSON"))
st_write(bounds,"03_preprocessing_files/bounds.geoJSON")
```

## Cleaning and simplifying
The `ref` attribute is filled based on the neighbouring links. 
```{r attr_filling}
network_fill = osm_fill_ref2(network)
```
## Spatial join with counts

```{r load_aadf}
aadf_data <- read_csv(
  "03_preprocessing_files/aadf_data.csv",
  col_types = cols(
    group_id = col_double(),
    subgroup_id = col_double(),
    flow.2022 = col_double(),
    flow.2023 = col_double()
    )
  )
```

Joining the counts and the spatial data
```{r join_counts}
sf_aadf <- sf_counts |> 
  left_join(aadf_data,by = join_by(group_id, subgroup_id))
```

A quick visualisation
```{r map_net_counts}
tmap_mode("plot")
tm_basemap("OpenStreetMap")+
tm_shape(bounds)+
  tm_polygons(alpha = 0.3)+
  tm_shape(network)+
  tm_lines(col = "orange",alpha = 0.4)+
  tm_shape(sf_aadf)+
  tm_dots(col = "blue")
```

It is assumed that the locations of the loops are correct and the uncertainty of the coordinates is very small. Links within 20 metres from the count are considered and then filtered using the described direction, and the nearest feature/link with the correct bearing is selected. If two or more counts are assigned to the same road link/graph edge the mean 

<!-- Include something to describe the bearing check -->

Using a similar approach as in the `assign_aadt_major` of the `MinorRoadsTraffic` package, an alternative function is defined.

```{r aadf_assign}
lines <- network_fill
traffic <- sf_aadf

major_ref = c("motorway",
              "motorway_link",
              "primary",
              "primary_link",
              "trunk",
              "trunk_link")

graph <- dodgr::weight_streetnet(lines,
                                 keep_cols = c("name","ref","highway","junction","maxspeed","oneway")
                                 )

graph_sf <- dodgr::dodgr_to_sf(graph) |> st_transform(27700)

traffic_buffer <- traffic |> st_buffer(20)

road_intersects <- st_intersects(traffic_buffer,graph_sf)

t_count <- 106

dirs_tbl <-
  tibble(
    dir_str = c(
      "southbound",
      "westbound",
      "northbound",
      "eastbound",
      "northeastbound",
      "northwestbound",
      "southeastbound",
      "southwestbound"
    ),
    t_bearing = c(180, -90, 0, 90,
                  45, -45, -135, 135)
  )

b_tolerance <- 90


traffic$edge_id <- vapply(seq_len(nrow(traffic_buffer)),
       function(t_count){
  str_dir_bearing <- dirs_tbl$t_bearing[traffic_buffer$dir_str[t_count]==dirs_tbl$dir_str]
  
  sel_road_links = graph_sf[road_intersects[[t_count]],]
  
  if(nrow(sel_road_links)>0) {
    sel_road_links$bearing = stplanr::line_bearing(l = sel_road_links |> st_transform(crs = 4326))
    
    sel_road_links$bearing_check = (str_dir_bearing - abs(sel_road_links$bearing))  < b_tolerance
    
    sel_road_links = sel_road_links[sel_road_links$bearing_check, ]
    
    t_edge = sel_road_links[st_nearest_feature(traffic[t_count, ], sel_road_links), ] |> st_drop_geometry()
    
    return(t_edge$edge_id)
  } else{
    return(NA_character_)
  }
  
  },
  character(1))

edge_flow <- traffic |>
  st_drop_geometry() |>
  drop_na(edge_id) |>
  summarise(across(starts_with("flow"),mean),.by = edge_id)

graph_contr = dodgr::dodgr_contract_graph(graph)

graph_sf_flows <- graph_sf |>
  left_join(edge_flow,by="edge_id")

graph_sf_flows$road_type <-
  dplyr::if_else(graph_sf_flows$highway %in% major_ref,
                 "major",
                 "minor")

```


The following map shows the road network and the flows that have been assigned
```{r assign_map}
tmap_mode("view")
tm_shape(graph_sf_flows |> filter(is.na(flow.2023)))+
  tm_lines("grey",lwd = 1)+
  tm_shape(traffic)+
  tm_dots("blue",alpha=0.5)+
  tm_shape(graph_sf_flows |> drop_na(flow.2023))+
  tm_lines("flow.2023",lwd = 1.5)
```

Junctions are extracted from the contracted graph

```{r jct_ext}
junctions <- dodgr::dodgr_vertices(graph_contr) |>
  st_as_sf(coords = c("x","y"),
           crs = 4326)
```

Junctions will be classified as minor, major and minor-major depending on the adjacent links.

```{r jct_classification}
junction_class_to <- graph_sf_flows |>
  st_drop_geometry() |>
  summarise(count = n(),.by = c(to_id,road_type)) |>
  pivot_wider(names_from = road_type,values_from = count)|> 
  rename(id = to_id)

junction_class_from <- graph_sf_flows |>
  st_drop_geometry() |>
  summarise(count = n(),.by = c(from_id,road_type)) |>
  pivot_wider(names_from = road_type,values_from = count) |>
  rename(id = from_id)


junctions_classed <- junction_class_to |> 
  full_join(junction_class_from,by = "id",suffix = c(".to",".from")) |> 
  mutate(jtc_type = case_when(is.na(minor.to)&is.na(minor.from)~"major",
                              is.na(major.to)&is.na(major.from)~"minor",
                              (!is.na(minor.to)&!is.na(major.from))|
                                (!is.na(minor.from)&!is.na(major.to))~"minmaj")) |> 
  select(-starts_with("m"))
rm(junction_class_from,junction_class_to)
```

Mean incoming approach flows  are calculated for all junctions, i.e. if a junction has 4 incoming roads/edges, an average of the 4 is calculated. Outgoing flows are not considered to avoid double-counting since the in and out flows should be the same.  

```{r jct_flows}
junctions_in_flows <- graph_sf_flows |>
  st_drop_geometry() |>
  summarise(across(starts_with("flow"),\(x) mean(x,na.rm = T)),.by = c(to_id))|> 
  rename(id = to_id)
```

```{r jct_consolidate}
junctions_flows <- junctions |> 
  left_join(junctions_in_flows,by = "id") |> 
  left_join(junctions_classed,by = "id")
rm(junctions_classed,junctions_in_flows,junctions)
```

The following map shows the average flow in Minor-Major junctions.

```{r minmaj_jct_plot}
tmap_mode("plot")
tm_shape(graph_sf_flows)+
  tm_lines("#87CEFA",lwd = 1)+
  tm_shape(junctions_flows |> filter(jtc_type == "minmaj"))+
  tm_dots(col = "flow.2023",size = 0.2, title = "AADF 2023")
```


## Saving data
```{r save_network_data}
network_data <- list(network = graph_sf_flows,
                     junctions = junctions_flows,
                     graph = graph)
write_rds(network_data,file = "03_preprocessing_files/network_data.rds")
try(file.remove("03_preprocessing_files/raw_network.geoJSON"))
st_write(network_fill,"03_preprocessing_files/raw_network.geoJSON")
try(file.remove("03_preprocessing_files/sf_junctions.geoJSON"))
st_write(junctions_flows,"03_preprocessing_files/sf_junctions.geoJSON")
```


