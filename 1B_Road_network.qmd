---
title: "Road Network"
author: "Juan Fonseca"
format: html
---
```{r libraries}
library(tidyverse)
library(dodgr)
library(osmextract)
library(sf)
library(tmap)
library(stplanr)
```

The following code uses some functions compiled in the `MinorRoadTraffic` repository prepared by Malcolm Morgan and follows the process described in [this vignette](https://github.com/ITSLeeds/MinorRoadTraffic/blob/main/vignettes/IOW.Rmd) of the same package.

```{r minor_library}
# remotes::install_github("ITSLeeds/MinorRoadTraffic") # if not installed
library(MinorRoadTraffic)
```

## Downloading data

```{r osm_get}
osm_raw <- oe_get("East Yorkshire with Hull",
                 extra_tags = c("ref", "highway", "junction", "maxspeed","oneway"))
```

## Clipping road network

The count data will be used to clip the road network.
```{r sf_counts}
sf_counts <- st_read("03_preprocessing_files/grouped_counts.geojson")
```


```{r clipping}
buffer_distance = max(st_distance(sf_counts,sf_counts))*0.15

bounds <- sf_counts |>
  make_convex_hull(dist = buffer_distance)

osm_clean = extract_from_osm(osm_raw,
                             bounds,
                             col_names = c("osm_id","name","ref","highway",
                                           "junction","maxspeed","geometry","oneway"))

network = osm_clean$network
junctions = osm_clean$junctions
rm(osm_clean, osm_raw)
```

```{r saving_bounds,include=FALSE}
try(file.remove("03_preprocessing_files/bounds.geoJSON"))
st_write(bounds,"03_preprocessing_files/bounds.geoJSON")
```

## Cleaning and simplifying
The `ref` attribute is filled based on the neighbouring links. 
```{r attr_filling}
network_fill = osm_fill_ref2(network)
```
## Saving data
```{r saving_network}
try(file.remove("03_preprocessing_files/network.geoJSON"))
try(st_write(network_fill,"03_preprocessing_files/network.geoJSON"))

try(file.remove("03_preprocessing_files/junctions.geoJSON"))
try(st_write(junctions,"03_preprocessing_files/junctions.geoJSON"))
```
## Spatial join with counts

```{r load_aadf}
aadf_data <- read_csv(
  "03_preprocessing_files/aadf_data.csv",
  col_types = cols(
    group_id = col_double(),
    subgroup_id = col_double(),
    flow.2022 = col_double(),
    flow.2023 = col_double()
    )
  )
```

Joining the counts and the spatial data
```{r join_counts}
sf_aadf <- sf_counts |> 
  left_join(aadf_data,by = join_by(group_id, subgroup_id))
```

A quick visualisation

```{r map_net_counts}
tmap_mode("plot")
tm_basemap("OpenStreetMap")+
tm_shape(bounds)+
  tm_polygons(alpha = 0.3)+
  tm_shape(network)+
  tm_lines(col = "orange",alpha = 0.4)+
  tm_shape(sf_aadf)+
  tm_dots(col = "blue")
```

It is assumed that the locations of the loops are correct and the uncertainty of the coordinates is very small, thus their are assigned to the nearest network link. A quick check of the bearing based on the direction is performed, although it was noticed that some of the descriptions are not accurate.

```{r aadf_assign}
lines <- network_fill
junctions <- junctions

traffic <- sf_aadf



major_ref = c("motorway",
              "motorway_link",
              "primary",
              "primary_link",
              "trunk",
              "trunk_link")





graph <- dodgr::weight_streetnet(lines,
                                 keep_cols = c("name","ref","highway","junction","maxspeed","oneway")
                                 )



graph_sf <- dodgr::dodgr_to_sf(graph) |> st_transform(27700)

traffic_buffer <- traffic |> st_buffer(20)

road_intersects <- st_intersects(traffic_buffer,graph_sf)

t_count <- 106

dirs_tbl <-
  tibble(
    dir_str = c(
      "southbound",
      "westbound",
      "northbound",
      "eastbound",
      "northeastbound",
      "northwestbound",
      "southeastbound",
      "southwestbound"
    ),
    t_bearing = c(180, -90, 0, 90,
                  45, -45, -135, 135)
  )

b_tolerance <- 90


traffic$edge_id <- vapply(seq_len(nrow(traffic_buffer)),
       function(t_count){
  str_dir_bearing <- dirs_tbl$t_bearing[traffic_buffer$dir_str[t_count]==dirs_tbl$dir_str]
  
  sel_road_links = graph_sf[road_intersects[[t_count]],]
  
  if(nrow(sel_road_links)>0) {
    sel_road_links$bearing = stplanr::line_bearing(l = sel_road_links |> st_transform(crs = 4326))
    
    sel_road_links$bearing_check = (str_dir_bearing - abs(sel_road_links$bearing))  < b_tolerance
    
    sel_road_links = sel_road_links[sel_road_links$bearing_check, ]
    
    t_edge = sel_road_links[st_nearest_feature(traffic[t_count, ], sel_road_links), ] |> st_drop_geometry()
    
    return(t_edge$edge_id)
  } else{
    return(NA_character_)
  }
  
  },
  character(1))


edge_flow <- traffic |>
  st_drop_geometry() |>
  drop_na(edge_id) |>
  summarise(across(starts_with("flow"),mean),.by = edge_id)

graph_contr = dodgr::dodgr_contract_graph(graph)

graph_sf_flows <- graph_sf |> left_join(edge_flow,by="edge_id")

tm_shape(graph_sf_flows |> filter(is.na(flow.2023)))+
  tm_lines("grey",lwd = 1)+
  tm_shape(graph_sf_flows |> drop_na(flow.2023))+
  tm_lines("flow.2023",lwd = 1.5)+
  tm_shape(traffic)+
  tm_dots("blue")



graph_sf_flows$road_type <-
  dplyr::if_else(graph_sf_flows$highway %in% major_ref, "major", "minor")



# Transform to Britsh National Grid
junctions = sf::st_transform(junctions, 27700)
bounds = sf::st_transform(bounds, 27700)

```






