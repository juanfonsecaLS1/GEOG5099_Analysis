---
title: "Road Network"
author: "Juan Fonseca"
format: html
---
```{r libraries}
library(tidyverse)
library(dodgr)
library(osmextract)
library(sf)
library(tmap)
library(stplanr)
```

The following code uses some functions compiled in the `MinorRoadTraffic` repository prepared by Malcolm Morgan and follows the process described in [this vignette](https://github.com/ITSLeeds/MinorRoadTraffic/blob/main/vignettes/IOW.Rmd) of the same package.

```{r minor_library}
# remotes::install_github("ITSLeeds/MinorRoadTraffic") # if not installed
library(MinorRoadTraffic)
```

## Downloading data

```{r osm_get}
osm_raw <- oe_get("East Yorkshire with Hull",
                 extra_tags = c("ref", "highway", "junction", "maxspeed"))
```

## Clipping road network

The count data will be used to clip the road network.
```{r sf_counts}
sf_counts <- st_read("03_preprocessing_files/grouped_counts.geojson")
```


```{r clipping}
buffer_distance = max(st_distance(sf_counts,sf_counts))*0.15

bounds <- sf_counts |>
  make_convex_hull(dist = buffer_distance)

osm_clean = extract_from_osm(osm_raw, bounds)

network = osm_clean$network
junctions = osm_clean$junctions
rm(osm_clean, osm_raw)
```

```{r saving_bounds,include=FALSE}
try(file.remove("03_preprocessing_files/bounds.geoJSON"))
st_write(bounds,"03_preprocessing_files/bounds.geoJSON")
```

## Cleaning and simplifying
The `ref` attribute is filled based on the neighbouring links. 
```{r attr_filling}
network_fill = osm_fill_ref2(network)
```
## Saving data
```{r saving_network}
try(file.remove("03_preprocessing_files/network.geoJSON"))
try(st_write(network_fill2,"03_preprocessing_files/network.geoJSON"),silent = T)
```
## Spatial join with counts

```{r load_aadf}
aadf_data <- read_csv(
  "03_preprocessing_files/aadf_data.csv",
  col_types = cols(
    group_id = col_double(),
    subgroup_id = col_double(),
    flow.2022 = col_double(),
    flow.2023 = col_double()
    )
  )
```

Joining the counts and the spatial data
```{r join_counts}
sf_aadf <- sf_counts |> 
  left_join(aadf_data,by = join_by(group_id, subgroup_id))
```

A quick visualisation

```{r map_net_counts}
tmap_mode("plot")
tm_basemap("OpenStreetMap")+
tm_shape(bounds)+
  tm_polygons(alpha = 0.3)+
  tm_shape(network)+
  tm_lines(col = "orange",alpha = 0.4)+
  tm_shape(sf_aadf)+
  tm_dots(col = "blue")
```


It is assumed that the locations of the loops do not have major error, thus their are assigned to the nearest network link. A quick check of the bearing based on the direction is performed, although it was noticed that some of the descriptions are not accurate.

```{r aadf_assign}
lines <- network_fill
junctions <- junctions

traffic <- sf_aadf


major_ref = c("motorway",
              "motorway_link",
              "primary",
              "primary_link",
              "trunk",
              "trunk_link")


lines$bearing <- stplanr::line_bearing(l = lines)

lines$road_type <-
  dplyr::if_else(lines$highway %in% major_ref, "major", "minor")


# Transform to Britsh National Grid
lines = sf::st_transform(lines, 27700)
junctions = sf::st_transform(junctions, 27700)
traffic = sf::st_transform(traffic, 27700)
bounds = sf::st_transform(bounds, 27700)

traffic$nearest_road <- st_nearest_feature(traffic, lines)



traffic$bearing <- lines$bearing[traffic$nearest_road]

dirs_tbl <-
  tibble(
    dir_str = c(
      "southbound",
      "westbound",
      "northbound",
      "eastbound",
      "northeastbound",
      "northwestbound",
      "southeastbound",
      "southwestbound"
    ),
    t_bearing = c(180, -90, 0, 90,
                  45, -45, -135, 135)
  )

tolerance <- 50

traffic_check <- traffic |>
  left_join(dirs_tbl, by = "dir_str") |>
  mutate(
    bearing_check_1 = abs(bearing - t_bearing),
    bearing_check_2 = 180 - abs(bearing - t_bearing),
    bearing_check = bearing_check_1 < tolerance | bearing_check_2 < tolerance)

```


```{r map_bearing_check}

tm_basemap("OpenStreetMap")+
    tm_shape(lines)+
    tm_lines(col = "orange")+
    tm_shape(traffic_check)+
    tm_dots(col = "bearing_check",popup.vars = TRUE)
  
```



